{"ast":null,"code":"var atob = require(\"atob\");\n\nvar urlLib = require(\"url\");\n\nvar pathLib = require(\"path\");\n\nvar decodeUriComponentLib = require(\"decode-uri-component\");\n\nfunction resolveUrl()\n/* ...urls */\n{\n  return Array.prototype.reduce.call(arguments, function (resolved, nextUrl) {\n    return urlLib.resolve(resolved, nextUrl);\n  });\n}\n\nfunction convertWindowsPath(aPath) {\n  return pathLib.sep === \"\\\\\" ? aPath.replace(/\\\\/g, \"/\").replace(/^[a-z]:\\/?/i, \"/\") : aPath;\n}\n\nfunction customDecodeUriComponent(string) {\n  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.\n  return decodeUriComponentLib(string.replace(/\\+/g, \"%2B\"));\n}\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function () {\n    callback(error, result);\n  });\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = customDecodeUriComponent(url);\n\n  try {\n    return String(read(readUrl));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nvar innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/;\nvar sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n\nfunction getSourceMappingUrl(code) {\n  var match = code.match(sourceMappingURLRegex);\n  return match ? match[1] || match[2] || \"\" : null;\n}\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData;\n\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl);\n  } catch (error) {\n    return callbackAsync(callback, error);\n  }\n\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData);\n  }\n\n  var readUrl = customDecodeUriComponent(mapData.url);\n  read(readUrl, function (error, result) {\n    if (error) {\n      error.sourceMapData = mapData;\n      return callback(error);\n    }\n\n    mapData.map = String(result);\n\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } catch (error) {\n      return callback(error);\n    }\n\n    callback(null, mapData);\n  });\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl);\n\n  if (!mapData || mapData.map) {\n    return mapData;\n  }\n\n  mapData.map = readSync(read, mapData.url, mapData);\n  mapData.map = parseMapToJSON(mapData.map, mapData);\n  return mapData;\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n/**\r\n * The media type for JSON text is application/json.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\r\n *\r\n * `text/json` is non-standard media type\r\n */\n\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n/**\r\n * JSON text exchanged between systems that are not part of a closed ecosystem\r\n * MUST be encoded using UTF-8.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\r\n */\n\nvar jsonCharacterEncoding = \"utf-8\";\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64);\n  var len = binStr.length;\n  var arr = new Uint8Array(len);\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64);\n  }\n\n  var buf = base64ToBuf(b64); // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n\n  var decoder = new TextDecoder(jsonCharacterEncoding, {\n    fatal: true\n  });\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = convertWindowsPath(codeUrl);\n  var url = getSourceMappingUrl(code);\n\n  if (!url) {\n    return null;\n  }\n\n  var dataUri = url.match(dataUriRegex);\n\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\";\n    var lastParameter = dataUri[2] || \"\";\n    var encoded = dataUri[3] || \"\";\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    };\n\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType);\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    try {\n      data.map = parseMapToJSON(lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    return data;\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url);\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  };\n}\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var pending = map.sources ? map.sources.length : 0;\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result);\n    return;\n  }\n\n  var done = function () {\n    pending--;\n\n    if (pending === 0) {\n      callback(null, result);\n    }\n  };\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent;\n      callbackAsync(done, null);\n    } else {\n      var readUrl = customDecodeUriComponent(fullUrl);\n      read(readUrl, function (error, source) {\n        result.sourcesContent[index] = error ? error : String(source);\n        done();\n      });\n    }\n  });\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (!map.sources || map.sources.length === 0) {\n    return result;\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n      } else {\n        var readUrl = customDecodeUriComponent(fullUrl);\n\n        try {\n          result.sourcesContent[index] = String(read(readUrl));\n        } catch (error) {\n          result.sourcesContent[index] = error;\n        }\n      }\n    }\n  });\n  return result;\n}\n\nvar endingSlash = /\\/?$/;\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {};\n  mapUrl = convertWindowsPath(mapUrl);\n  var fullUrl;\n  var sourceContent;\n  var sourceRoot;\n\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null;\n\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot;\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot;\n    } // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n\n\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index]);\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n    }\n\n    sourceContent = (map.sourcesContent || [])[index];\n    fn(fullUrl, sourceContent, index);\n  }\n}\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    var readUrl = customDecodeUriComponent(mapUrl);\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = data;\n        return callback(error);\n      }\n\n      data.map = String(result);\n\n      try {\n        data.map = parseMapToJSON(data.map, data);\n      } catch (error) {\n        return callback(error);\n      }\n\n      _resolveSources(data);\n    });\n  } else {\n    resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n      if (error) {\n        return callback(error);\n      }\n\n      if (!mapData) {\n        return callback(null, null);\n      }\n\n      _resolveSources(mapData);\n    });\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n      if (error) {\n        return callback(error);\n      }\n\n      mapData.sourcesResolved = result.sourcesResolved;\n      mapData.sourcesContent = result.sourcesContent;\n      callback(null, mapData);\n    });\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData;\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    mapData.map = readSync(read, mapUrl, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read);\n\n    if (!mapData) {\n      return null;\n    }\n  }\n\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n  mapData.sourcesResolved = result.sourcesResolved;\n  mapData.sourcesContent = result.sourcesContent;\n  return mapData;\n}\n\nmodule.exports = {\n  resolveSourceMap: resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources: resolveSources,\n  resolveSourcesSync: resolveSourcesSync,\n  resolve: resolve,\n  resolveSync: resolveSync,\n  parseMapToJSON: parseMapToJSON\n};","map":{"version":3,"sources":["C:/Users/jpluc/Documents/React/Cursos/React/React - Redux/fundamentos-react/node_modules/@testing-library/jest-dom/node_modules/source-map-resolve/index.js"],"names":["atob","require","urlLib","pathLib","decodeUriComponentLib","resolveUrl","Array","prototype","reduce","call","arguments","resolved","nextUrl","resolve","convertWindowsPath","aPath","sep","replace","customDecodeUriComponent","string","callbackAsync","callback","error","result","setImmediate","parseMapToJSON","data","JSON","parse","sourceMapData","readSync","read","url","readUrl","String","innerRegex","sourceMappingURLRegex","RegExp","source","getSourceMappingUrl","code","match","resolveSourceMap","codeUrl","mapData","resolveSourceMapHelper","map","resolveSourceMapSync","dataUriRegex","jsonMimeTypeRegex","jsonCharacterEncoding","base64ToBuf","b64","binStr","len","length","arr","Uint8Array","i","charCodeAt","decodeBase64String","TextDecoder","buf","decoder","fatal","decode","dataUri","mimeType","lastParameter","encoded","sourceMappingURL","sourcesRelativeTo","test","Error","decodeURIComponent","mapUrl","resolveSources","options","pending","sources","sourcesResolved","sourcesContent","done","resolveSourcesHelper","fullUrl","sourceContent","index","resolveSourcesSync","endingSlash","fn","sourceRoot","_resolveSources","resolveSync","module","exports"],"mappings":"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","sourcesContent":["var atob = require(\"atob\")\r\nvar urlLib = require(\"url\")\r\nvar pathLib = require(\"path\")\r\nvar decodeUriComponentLib = require(\"decode-uri-component\")\r\n\r\n\r\n\r\nfunction resolveUrl(/* ...urls */) {\r\n  return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {\r\n    return urlLib.resolve(resolved, nextUrl)\r\n  })\r\n}\r\n\r\nfunction convertWindowsPath(aPath) {\r\n  return pathLib.sep === \"\\\\\" ? aPath.replace(/\\\\/g, \"/\").replace(/^[a-z]:\\/?/i, \"/\") : aPath\r\n}\r\n\r\nfunction customDecodeUriComponent(string) {\r\n  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.\r\n  return decodeUriComponentLib(string.replace(/\\+/g, \"%2B\"))\r\n}\r\n\r\nfunction callbackAsync(callback, error, result) {\r\n  setImmediate(function() { callback(error, result) })\r\n}\r\n\r\nfunction parseMapToJSON(string, data) {\r\n  try {\r\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\r\n  } catch (error) {\r\n    error.sourceMapData = data\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction readSync(read, url, data) {\r\n  var readUrl = customDecodeUriComponent(url)\r\n  try {\r\n    return String(read(readUrl))\r\n  } catch (error) {\r\n    error.sourceMapData = data\r\n    throw error\r\n  }\r\n}\r\n\r\n\r\n\r\nvar innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/\r\n\r\nvar sourceMappingURLRegex = RegExp(\r\n  \"(?:\" +\r\n    \"/\\\\*\" +\r\n    \"(?:\\\\s*\\r?\\n(?://)?)?\" +\r\n    \"(?:\" + innerRegex.source + \")\" +\r\n    \"\\\\s*\" +\r\n    \"\\\\*/\" +\r\n    \"|\" +\r\n    \"//(?:\" + innerRegex.source + \")\" +\r\n  \")\" +\r\n  \"\\\\s*\"\r\n)\r\n\r\nfunction getSourceMappingUrl(code) {\r\n  var match = code.match(sourceMappingURLRegex)\r\n  return match ? match[1] || match[2] || \"\" : null\r\n}\r\n\r\n\r\n\r\nfunction resolveSourceMap(code, codeUrl, read, callback) {\r\n  var mapData\r\n  try {\r\n    mapData = resolveSourceMapHelper(code, codeUrl)\r\n  } catch (error) {\r\n    return callbackAsync(callback, error)\r\n  }\r\n  if (!mapData || mapData.map) {\r\n    return callbackAsync(callback, null, mapData)\r\n  }\r\n  var readUrl = customDecodeUriComponent(mapData.url)\r\n  read(readUrl, function(error, result) {\r\n    if (error) {\r\n      error.sourceMapData = mapData\r\n      return callback(error)\r\n    }\r\n    mapData.map = String(result)\r\n    try {\r\n      mapData.map = parseMapToJSON(mapData.map, mapData)\r\n    } catch (error) {\r\n      return callback(error)\r\n    }\r\n    callback(null, mapData)\r\n  })\r\n}\r\n\r\nfunction resolveSourceMapSync(code, codeUrl, read) {\r\n  var mapData = resolveSourceMapHelper(code, codeUrl)\r\n  if (!mapData || mapData.map) {\r\n    return mapData\r\n  }\r\n  mapData.map = readSync(read, mapData.url, mapData)\r\n  mapData.map = parseMapToJSON(mapData.map, mapData)\r\n  return mapData\r\n}\r\n\r\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\r\n\r\n/**\r\n * The media type for JSON text is application/json.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\r\n *\r\n * `text/json` is non-standard media type\r\n */\r\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/\r\n\r\n/**\r\n * JSON text exchanged between systems that are not part of a closed ecosystem\r\n * MUST be encoded using UTF-8.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\r\n */\r\nvar jsonCharacterEncoding = \"utf-8\"\r\n\r\nfunction base64ToBuf(b64) {\r\n  var binStr = atob(b64)\r\n  var len = binStr.length\r\n  var arr = new Uint8Array(len)\r\n  for (var i = 0; i < len; i++) {\r\n    arr[i] = binStr.charCodeAt(i)\r\n  }\r\n  return arr\r\n}\r\n\r\nfunction decodeBase64String(b64) {\r\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\r\n    return atob(b64)\r\n  }\r\n  var buf = base64ToBuf(b64);\r\n  // Note: `decoder.decode` method will throw a `DOMException` with the\r\n  // `\"EncodingError\"` value when an coding error is found.\r\n  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\r\n  return decoder.decode(buf);\r\n}\r\n\r\nfunction resolveSourceMapHelper(code, codeUrl) {\r\n  codeUrl = convertWindowsPath(codeUrl)\r\n\r\n  var url = getSourceMappingUrl(code)\r\n  if (!url) {\r\n    return null\r\n  }\r\n\r\n  var dataUri = url.match(dataUriRegex)\r\n  if (dataUri) {\r\n    var mimeType = dataUri[1] || \"text/plain\"\r\n    var lastParameter = dataUri[2] || \"\"\r\n    var encoded = dataUri[3] || \"\"\r\n    var data = {\r\n      sourceMappingURL: url,\r\n      url: null,\r\n      sourcesRelativeTo: codeUrl,\r\n      map: encoded\r\n    }\r\n    if (!jsonMimeTypeRegex.test(mimeType)) {\r\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType)\r\n      error.sourceMapData = data\r\n      throw error\r\n    }\r\n    try {\r\n      data.map = parseMapToJSON(\r\n        lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded),\r\n        data\r\n      )\r\n    } catch (error) {\r\n      error.sourceMapData = data\r\n      throw error\r\n    }\r\n    return data\r\n  }\r\n\r\n  var mapUrl = resolveUrl(codeUrl, url)\r\n  return {\r\n    sourceMappingURL: url,\r\n    url: mapUrl,\r\n    sourcesRelativeTo: mapUrl,\r\n    map: null\r\n  }\r\n}\r\n\r\n\r\n\r\nfunction resolveSources(map, mapUrl, read, options, callback) {\r\n  if (typeof options === \"function\") {\r\n    callback = options\r\n    options = {}\r\n  }\r\n  var pending = map.sources ? map.sources.length : 0\r\n  var result = {\r\n    sourcesResolved: [],\r\n    sourcesContent:  []\r\n  }\r\n\r\n  if (pending === 0) {\r\n    callbackAsync(callback, null, result)\r\n    return\r\n  }\r\n\r\n  var done = function() {\r\n    pending--\r\n    if (pending === 0) {\r\n      callback(null, result)\r\n    }\r\n  }\r\n\r\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\r\n    result.sourcesResolved[index] = fullUrl\r\n    if (typeof sourceContent === \"string\") {\r\n      result.sourcesContent[index] = sourceContent\r\n      callbackAsync(done, null)\r\n    } else {\r\n      var readUrl = customDecodeUriComponent(fullUrl)\r\n      read(readUrl, function(error, source) {\r\n        result.sourcesContent[index] = error ? error : String(source)\r\n        done()\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nfunction resolveSourcesSync(map, mapUrl, read, options) {\r\n  var result = {\r\n    sourcesResolved: [],\r\n    sourcesContent:  []\r\n  }\r\n\r\n  if (!map.sources || map.sources.length === 0) {\r\n    return result\r\n  }\r\n\r\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\r\n    result.sourcesResolved[index] = fullUrl\r\n    if (read !== null) {\r\n      if (typeof sourceContent === \"string\") {\r\n        result.sourcesContent[index] = sourceContent\r\n      } else {\r\n        var readUrl = customDecodeUriComponent(fullUrl)\r\n        try {\r\n          result.sourcesContent[index] = String(read(readUrl))\r\n        } catch (error) {\r\n          result.sourcesContent[index] = error\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  return result\r\n}\r\n\r\nvar endingSlash = /\\/?$/\r\n\r\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\r\n  options = options || {}\r\n  mapUrl = convertWindowsPath(mapUrl)\r\n  var fullUrl\r\n  var sourceContent\r\n  var sourceRoot\r\n  for (var index = 0, len = map.sources.length; index < len; index++) {\r\n    sourceRoot = null\r\n    if (typeof options.sourceRoot === \"string\") {\r\n      sourceRoot = options.sourceRoot\r\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\r\n      sourceRoot = map.sourceRoot\r\n    }\r\n    // If the sourceRoot is the empty string, it is equivalent to not setting\r\n    // the property at all.\r\n    if (sourceRoot === null || sourceRoot === '') {\r\n      fullUrl = resolveUrl(mapUrl, map.sources[index])\r\n    } else {\r\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\r\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\r\n      // does not make sense.\r\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\r\n    }\r\n    sourceContent = (map.sourcesContent || [])[index]\r\n    fn(fullUrl, sourceContent, index)\r\n  }\r\n}\r\n\r\n\r\n\r\nfunction resolve(code, codeUrl, read, options, callback) {\r\n  if (typeof options === \"function\") {\r\n    callback = options\r\n    options = {}\r\n  }\r\n  if (code === null) {\r\n    var mapUrl = codeUrl\r\n    var data = {\r\n      sourceMappingURL: null,\r\n      url: mapUrl,\r\n      sourcesRelativeTo: mapUrl,\r\n      map: null\r\n    }\r\n    var readUrl = customDecodeUriComponent(mapUrl)\r\n    read(readUrl, function(error, result) {\r\n      if (error) {\r\n        error.sourceMapData = data\r\n        return callback(error)\r\n      }\r\n      data.map = String(result)\r\n      try {\r\n        data.map = parseMapToJSON(data.map, data)\r\n      } catch (error) {\r\n        return callback(error)\r\n      }\r\n      _resolveSources(data)\r\n    })\r\n  } else {\r\n    resolveSourceMap(code, codeUrl, read, function(error, mapData) {\r\n      if (error) {\r\n        return callback(error)\r\n      }\r\n      if (!mapData) {\r\n        return callback(null, null)\r\n      }\r\n      _resolveSources(mapData)\r\n    })\r\n  }\r\n\r\n  function _resolveSources(mapData) {\r\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\r\n      if (error) {\r\n        return callback(error)\r\n      }\r\n      mapData.sourcesResolved = result.sourcesResolved\r\n      mapData.sourcesContent  = result.sourcesContent\r\n      callback(null, mapData)\r\n    })\r\n  }\r\n}\r\n\r\nfunction resolveSync(code, codeUrl, read, options) {\r\n  var mapData\r\n  if (code === null) {\r\n    var mapUrl = codeUrl\r\n    mapData = {\r\n      sourceMappingURL: null,\r\n      url: mapUrl,\r\n      sourcesRelativeTo: mapUrl,\r\n      map: null\r\n    }\r\n    mapData.map = readSync(read, mapUrl, mapData)\r\n    mapData.map = parseMapToJSON(mapData.map, mapData)\r\n  } else {\r\n    mapData = resolveSourceMapSync(code, codeUrl, read)\r\n    if (!mapData) {\r\n      return null\r\n    }\r\n  }\r\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\r\n  mapData.sourcesResolved = result.sourcesResolved\r\n  mapData.sourcesContent  = result.sourcesContent\r\n  return mapData\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n  resolveSourceMap:     resolveSourceMap,\r\n  resolveSourceMapSync: resolveSourceMapSync,\r\n  resolveSources:       resolveSources,\r\n  resolveSourcesSync:   resolveSourcesSync,\r\n  resolve:              resolve,\r\n  resolveSync:          resolveSync,\r\n  parseMapToJSON:       parseMapToJSON\r\n}\r\n"]},"metadata":{},"sourceType":"script"}